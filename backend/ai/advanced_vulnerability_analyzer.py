"""Advanced AI-powered vulnerability analysis and threat intelligence engine."""
import openai
import json
import re
from datetime import datetime
from typing import List, Dict, Any
import requests
from dataclasses import dataclass

@dataclass
class VulnerabilityContext:
    """Context information for vulnerability analysis."""
    cve_id: str = None
    cvss_score: float = None
    exploit_available: bool = False
    patch_available: bool = False
    asset_criticality: str = "medium"
    business_impact: str = "medium"
    threat_landscape: Dict = None

class AdvancedVulnerabilityAnalyzer:
    """AI-powered vulnerability analysis with threat intelligence."""
    
    def __init__(self, openai_api_key=None):
        self.openai_client = openai.OpenAI(api_key=openai_api_key) if openai_api_key else None
        self.vulnerability_database = {}
        self.threat_intelligence = {}
        
    def analyze_vulnerabilities(self, vulnerabilities: List[Dict]) -> Dict[str, Any]:
        """Perform comprehensive AI analysis of vulnerabilities."""
        analysis_results = {
            "executive_summary": "",
            "risk_assessment": {},
            "prioritized_vulnerabilities": [],
            "remediation_roadmap": [],
            "threat_landscape": {},
            "compliance_impact": {},
            "business_risk": {},
            "generated_at": datetime.utcnow().isoformat()
        }
        
        if not vulnerabilities:
            analysis_results["executive_summary"] = "No vulnerabilities detected. Security posture appears strong."
            return analysis_results
        
        # Enrich vulnerabilities with threat intelligence
        enriched_vulns = self._enrich_vulnerabilities(vulnerabilities)
        
        # Generate AI-powered executive summary
        analysis_results["executive_summary"] = self._generate_executive_summary(enriched_vulns)
        
        # Perform risk assessment
        analysis_results["risk_assessment"] = self._calculate_comprehensive_risk(enriched_vulns)
        
        # Prioritize vulnerabilities using AI
        analysis_results["prioritized_vulnerabilities"] = self._prioritize_vulnerabilities(enriched_vulns)
        
        # Generate remediation roadmap
        analysis_results["remediation_roadmap"] = self._generate_remediation_roadmap(enriched_vulns)
        
        # Assess threat landscape
        analysis_results["threat_landscape"] = self._assess_threat_landscape(enriched_vulns)
        
        # Evaluate compliance impact
        analysis_results["compliance_impact"] = self._evaluate_compliance_impact(enriched_vulns)
        
        # Calculate business risk
        analysis_results["business_risk"] = self._calculate_business_risk(enriched_vulns)
        
        return analysis_results
    
    def _enrich_vulnerabilities(self, vulnerabilities: List[Dict]) -> List[Dict]:
        """Enrich vulnerabilities with threat intelligence and context."""
        enriched = []
        
        for vuln in vulnerabilities:
            enriched_vuln = vuln.copy()
            
            # Add CVE information if available
            cve_info = self._lookup_cve_info(vuln)
            if cve_info:
                enriched_vuln.update(cve_info)
            
            # Add exploit information
            exploit_info = self._check_exploit_availability(vuln)
            enriched_vuln["exploit_info"] = exploit_info
            
            # Add patch information
            patch_info = self._check_patch_availability(vuln)
            enriched_vuln["patch_info"] = patch_info
            
            # Calculate dynamic risk score
            enriched_vuln["dynamic_risk_score"] = self._calculate_dynamic_risk_score(enriched_vuln)
            
            # Add business context
            enriched_vuln["business_context"] = self._add_business_context(enriched_vuln)
            
            enriched.append(enriched_vuln)
        
        return enriched
    
    def _generate_executive_summary(self, vulnerabilities: List[Dict]) -> str:
        """Generate AI-powered executive summary."""
        if not self.openai_client:
            return self._generate_fallback_summary(vulnerabilities)
        
        try:
            # Prepare vulnerability data for AI analysis
            vuln_summary = self._prepare_vulnerability_summary(vulnerabilities)
            
            prompt = f"""
            As a cybersecurity expert, analyze the following vulnerability assessment results and provide a comprehensive executive summary for C-level executives:
            
            Vulnerability Data:
            {vuln_summary}
            
            Please provide:
            1. Overall security posture assessment
            2. Key risk areas and their business impact
            3. Immediate actions required
            4. Strategic recommendations
            5. Resource requirements
            
            Keep the summary concise but comprehensive, focusing on business impact and actionable insights.
            """
            
            response = self.openai_client.chat.completions.create(
                model="gpt-4",
                messages=[
                    {"role": "system", "content": "You are a senior cybersecurity consultant providing executive briefings."},
                    {"role": "user", "content": prompt}
                ],
                max_tokens=1000,
                temperature=0.3
            )
            
            return response.choices[0].message.content
            
        except Exception as e:
            print(f"Error generating AI summary: {e}")
            return self._generate_fallback_summary(vulnerabilities)
    
    def _prioritize_vulnerabilities(self, vulnerabilities: List[Dict]) -> List[Dict]:
        """Use AI to prioritize vulnerabilities based on multiple factors."""
        prioritized = []
        
        for vuln in vulnerabilities:
            priority_score = self._calculate_priority_score(vuln)
            vuln["priority_score"] = priority_score
            vuln["priority_level"] = self._get_priority_level(priority_score)
            prioritized.append(vuln)
        
        # Sort by priority score (highest first)
        prioritized.sort(key=lambda x: x["priority_score"], reverse=True)
        
        return prioritized
    
    def _calculate_priority_score(self, vulnerability: Dict) -> float:
        """Calculate comprehensive priority score for vulnerability."""
        base_score = 0.0
        
        # CVSS score factor (0-40 points)
        cvss = vulnerability.get("cvss_score", vulnerability.get("severity_numeric", 5.0))
        if isinstance(cvss, str):
            cvss_map = {"low": 3.0, "medium": 5.0, "high": 7.5, "critical": 9.0}
            cvss = cvss_map.get(cvss.lower(), 5.0)
        base_score += (cvss / 10.0) * 40
        
        # Exploit availability factor (0-25 points)
        if vulnerability.get("exploit_info", {}).get("exploit_available", False):
            base_score += 25
        elif vulnerability.get("exploit_info", {}).get("poc_available", False):
            base_score += 15
        
        # Asset criticality factor (0-20 points)
        criticality = vulnerability.get("business_context", {}).get("asset_criticality", "medium")
        criticality_scores = {"low": 5, "medium": 10, "high": 15, "critical": 20}
        base_score += criticality_scores.get(criticality, 10)
        
        # Patch availability factor (-10 to +10 points)
        patch_info = vulnerability.get("patch_info", {})
        if patch_info.get("patch_available", False):
            if patch_info.get("patch_age_days", 0) > 30:
                base_score += 10  # Old patch, higher priority
            else:
                base_score -= 5   # Recent patch, slightly lower priority
        else:
            base_score += 5     # No patch, higher priority
        
        # Threat landscape factor (0-15 points)
        if vulnerability.get("threat_landscape", {}).get("active_campaigns", False):
            base_score += 15
        elif vulnerability.get("threat_landscape", {}).get("trending", False):
            base_score += 10
        
        return min(base_score, 100.0)  # Cap at 100
    
    def _generate_remediation_roadmap(self, vulnerabilities: List[Dict]) -> List[Dict]:
        """Generate intelligent remediation roadmap."""
        roadmap = []
        
        # Group vulnerabilities by remediation type
        remediation_groups = self._group_by_remediation(vulnerabilities)
        
        for group_name, group_vulns in remediation_groups.items():
            roadmap_item = {
                "phase": self._determine_remediation_phase(group_vulns),
                "title": group_name,
                "vulnerabilities": len(group_vulns),
                "estimated_effort": self._estimate_remediation_effort(group_vulns),
                "business_impact": self._assess_remediation_impact(group_vulns),
                "dependencies": self._identify_dependencies(group_vulns),
                "success_criteria": self._define_success_criteria(group_vulns)
            }
            roadmap.append(roadmap_item)
        
        # Sort by phase and priority
        roadmap.sort(key=lambda x: (x["phase"], -len(x["vulnerabilities"])))
        
        return roadmap
    
    def _assess_threat_landscape(self, vulnerabilities: List[Dict]) -> Dict[str, Any]:
        """Assess current threat landscape relevant to vulnerabilities."""
        threat_assessment = {
            "overall_threat_level": "medium",
            "active_campaigns": [],
            "trending_attacks": [],
            "geographic_threats": [],
            "industry_specific_threats": [],
            "recommendations": []
        }
        
        # Analyze vulnerability types for threat patterns
        vuln_types = [v.get("type", "") for v in vulnerabilities]
        
        # Check for high-risk vulnerability patterns
        high_risk_patterns = [
            "sql_injection", "xss", "rce", "authentication_bypass",
            "privilege_escalation", "directory_traversal"
        ]
        
        active_high_risk = [pattern for pattern in high_risk_patterns if pattern in vuln_types]
        
        if len(active_high_risk) > 2:
            threat_assessment["overall_threat_level"] = "high"
        elif len(active_high_risk) > 0:
            threat_assessment["overall_threat_level"] = "medium"
        else:
            threat_assessment["overall_threat_level"] = "low"
        
        # Add specific recommendations based on threat landscape
        threat_assessment["recommendations"] = self._generate_threat_recommendations(vulnerabilities)
        
        return threat_assessment
    
    def _evaluate_compliance_impact(self, vulnerabilities: List[Dict]) -> Dict[str, Any]:
        """Evaluate impact on compliance frameworks."""
        compliance_impact = {
            "frameworks_affected": [],
            "severity_by_framework": {},
            "remediation_requirements": {},
            "audit_implications": []
        }
        
        # Map vulnerabilities to compliance frameworks
        framework_mappings = {
            "PCI DSS": ["sql_injection", "xss", "authentication", "encryption"],
            "HIPAA": ["authentication", "encryption", "access_control"],
            "SOX": ["authentication", "access_control", "audit_logging"],
            "GDPR": ["encryption", "access_control", "data_protection"],
            "ISO 27001": ["all"]  # ISO 27001 covers all security aspects
        }
        
        for framework, relevant_types in framework_mappings.items():
            affected_vulns = []
            for vuln in vulnerabilities:
                vuln_type = vuln.get("type", "")
                if "all" in relevant_types or any(rt in vuln_type for rt in relevant_types):
                    affected_vulns.append(vuln)
            
            if affected_vulns:
                compliance_impact["frameworks_affected"].append(framework)
                compliance_impact["severity_by_framework"][framework] = self._calculate_compliance_severity(affected_vulns)
        
        return compliance_impact
    
    def _calculate_business_risk(self, vulnerabilities: List[Dict]) -> Dict[str, Any]:
        """Calculate comprehensive business risk assessment."""
        business_risk = {
            "overall_risk_score": 0.0,
            "financial_impact": {},
            "operational_impact": {},
            "reputational_impact": {},
            "regulatory_impact": {},
            "mitigation_cost": {}
        }
        
        # Calculate overall risk score
        total_risk = sum(v.get("dynamic_risk_score", 50) for v in vulnerabilities)
        business_risk["overall_risk_score"] = min(total_risk / len(vulnerabilities) if vulnerabilities else 0, 100)
        
        # Estimate financial impact
        high_severity_count = len([v for v in vulnerabilities if v.get("severity") in ["high", "critical"]])
        business_risk["financial_impact"] = {
            "potential_loss_range": f"${high_severity_count * 50000} - ${high_severity_count * 500000}",
            "breach_probability": min(high_severity_count * 0.1, 0.8),
            "insurance_impact": "moderate" if high_severity_count > 5 else "low"
        }
        
        return business_risk
    
    # Helper methods
    def _lookup_cve_info(self, vulnerability: Dict) -> Dict:
        """Lookup CVE information for vulnerability."""
        # Placeholder for CVE database lookup
        return {"cve_id": None, "cvss_score": None}
    
    def _check_exploit_availability(self, vulnerability: Dict) -> Dict:
        """Check if exploits are available for vulnerability."""
        return {"exploit_available": False, "poc_available": False}
    
    def _check_patch_availability(self, vulnerability: Dict) -> Dict:
        """Check patch availability for vulnerability."""
        return {"patch_available": True, "patch_age_days": 30}
    
    def _calculate_dynamic_risk_score(self, vulnerability: Dict) -> float:
        """Calculate dynamic risk score based on multiple factors."""
        return self._calculate_priority_score(vulnerability)
    
    def _add_business_context(self, vulnerability: Dict) -> Dict:
        """Add business context to vulnerability."""
        return {"asset_criticality": "medium", "business_function": "general"}
    
    def _prepare_vulnerability_summary(self, vulnerabilities: List[Dict]) -> str:
        """Prepare vulnerability summary for AI analysis."""
        summary = f"Total vulnerabilities: {len(vulnerabilities)}\n"
        
        severity_counts = {}
        for vuln in vulnerabilities:
            severity = vuln.get("severity", "unknown")
            severity_counts[severity] = severity_counts.get(severity, 0) + 1
        
        summary += f"Severity breakdown: {severity_counts}\n"
        
        # Add top 5 vulnerabilities
        summary += "Top vulnerabilities:\n"
        for i, vuln in enumerate(vulnerabilities[:5]):
            summary += f"{i+1}. {vuln.get('title', 'Unknown')} - {vuln.get('severity', 'unknown')}\n"
        
        return summary
    
    def _generate_fallback_summary(self, vulnerabilities: List[Dict]) -> str:
        """Generate fallback summary when AI is not available."""
        total = len(vulnerabilities)
        if total == 0:
            return "No vulnerabilities detected. Security posture appears strong."
        
        severity_counts = {}
        for vuln in vulnerabilities:
            severity = vuln.get("severity", "unknown")
            severity_counts[severity] = severity_counts.get(severity, 0) + 1
        
        critical = severity_counts.get("critical", 0)
        high = severity_counts.get("high", 0)
        
        summary = f"Security assessment identified {total} vulnerabilities. "
        
        if critical > 0:
            summary += f"{critical} critical vulnerabilities require immediate attention. "
        if high > 0:
            summary += f"{high} high-severity vulnerabilities should be addressed within 7 days. "
        
        summary += "Recommend implementing a comprehensive remediation plan to address identified security gaps."
        
        return summary
    
    def _get_priority_level(self, score: float) -> str:
        """Convert priority score to level."""
        if score >= 80:
            return "critical"
        elif score >= 60:
            return "high"
        elif score >= 40:
            return "medium"
        else:
            return "low"
    
    def _group_by_remediation(self, vulnerabilities: List[Dict]) -> Dict[str, List[Dict]]:
        """Group vulnerabilities by remediation approach."""
        groups = {
            "Immediate Patching": [],
            "Configuration Changes": [],
            "Code Fixes": [],
            "Infrastructure Updates": [],
            "Policy Changes": []
        }
        
        for vuln in vulnerabilities:
            vuln_type = vuln.get("type", "")
            if "patch" in vuln.get("remediation", "").lower():
                groups["Immediate Patching"].append(vuln)
            elif vuln_type in ["misconfiguration", "ssl", "header"]:
                groups["Configuration Changes"].append(vuln)
            elif vuln_type in ["xss", "sql_injection", "csrf"]:
                groups["Code Fixes"].append(vuln)
            elif vuln_type in ["network", "port", "service"]:
                groups["Infrastructure Updates"].append(vuln)
            else:
                groups["Policy Changes"].append(vuln)
        
        # Remove empty groups
        return {k: v for k, v in groups.items() if v}
    
    def _determine_remediation_phase(self, vulnerabilities: List[Dict]) -> int:
        """Determine remediation phase (1=immediate, 2=short-term, 3=long-term)."""
        max_severity = max([self._get_severity_numeric(v.get("severity", "low")) for v in vulnerabilities])
        
        if max_severity >= 8:
            return 1  # Immediate
        elif max_severity >= 6:
            return 2  # Short-term
        else:
            return 3  # Long-term
    
    def _get_severity_numeric(self, severity: str) -> float:
        """Convert severity to numeric value."""
        severity_map = {"low": 3.0, "medium": 5.0, "high": 7.5, "critical": 9.0}
        return severity_map.get(severity.lower(), 5.0)
    
    def _estimate_remediation_effort(self, vulnerabilities: List[Dict]) -> str:
        """Estimate effort required for remediation."""
        total_vulns = len(vulnerabilities)
        if total_vulns <= 5:
            return "Low (1-2 weeks)"
        elif total_vulns <= 15:
            return "Medium (3-6 weeks)"
        else:
            return "High (6+ weeks)"
    
    def _assess_remediation_impact(self, vulnerabilities: List[Dict]) -> str:
        """Assess business impact of remediation."""
        return "Medium - Some system downtime may be required"
    
    def _identify_dependencies(self, vulnerabilities: List[Dict]) -> List[str]:
        """Identify remediation dependencies."""
        return ["Security team approval", "Change management process", "Testing environment"]
    
    def _define_success_criteria(self, vulnerabilities: List[Dict]) -> List[str]:
        """Define success criteria for remediation."""
        return [
            "All vulnerabilities resolved",
            "Security scan shows no issues",
            "No impact on system functionality"
        ]
    
    def _generate_threat_recommendations(self, vulnerabilities: List[Dict]) -> List[str]:
        """Generate threat-specific recommendations."""
        recommendations = [
            "Implement continuous security monitoring",
            "Establish incident response procedures",
            "Conduct regular security assessments",
            "Provide security awareness training"
        ]
        
        # Add specific recommendations based on vulnerability types
        vuln_types = [v.get("type", "") for v in vulnerabilities]
        
        if any("sql" in vt for vt in vuln_types):
            recommendations.append("Implement database activity monitoring")
        
        if any("xss" in vt for vt in vuln_types):
            recommendations.append("Deploy web application firewall")
        
        return recommendations
    
    def _calculate_compliance_severity(self, vulnerabilities: List[Dict]) -> str:
        """Calculate compliance severity for framework."""
        high_count = len([v for v in vulnerabilities if v.get("severity") in ["high", "critical"]])
        
        if high_count > 5:
            return "high"
        elif high_count > 2:
            return "medium"
        else:
            return "low"