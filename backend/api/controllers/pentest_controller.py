"""
Pentest controller for the modern API interface.
Provides endpoints for the penetration testing dashboard.
"""
from flask import request, jsonify
from flask_restful import Resource
from datetime import datetime
import uuid
from bson.objectid import ObjectId

from database.db import get_db
from orchestration.scan_orchestrator import ScanOrchestrator, ScanRequest, ScanType
import asyncio

class PentestController(Resource):
    """Controller for penetration testing operations."""
    
    def get(self, scan_id=None):
        """
        Get scan information.
        
        Args:
            scan_id: Optional ID of specific scan to retrieve
            
        Returns:
            JSON response with scan data
        """
        db = get_db()
        
        if scan_id:
            # Get specific scan
            scan = db.scans.find_one({"_id": scan_id})
            if not scan:
                return {"error": "Scan not found"}, 404
            
            # Convert ObjectId to string for JSON serialization
            if isinstance(scan.get("_id"), ObjectId):
                scan["_id"] = str(scan["_id"])
            
            return scan
        else:
            # Get all scans, sorted by start time (newest first)
            scans = list(db.scans.find().sort("start_time", -1).limit(20))
            
            # Convert ObjectId to string for JSON serialization
            for scan in scans:
                if isinstance(scan.get("_id"), ObjectId):
                    scan["_id"] = str(scan["_id"])
            
            return scans
    
    def post(self):
        """
        Create a new penetration test scan.
        
        Returns:
            JSON response with scan details
        """
        data = request.get_json()
        
        # Validate required fields
        required_fields = ["target", "scan_type"]
        for field in required_fields:
            if field not in data:
                return {"error": f"Missing required field: {field}"}, 400
        
        # Map frontend scan types to orchestrator scan types
        scan_type_mapping = {
            "webapp": ScanType.WEB_APP,
            "network": ScanType.NETWORK,
            "owasp": ScanType.WEB_APP,
            "full": ScanType.COMPREHENSIVE,
            "api-security": ScanType.WEB_APP,
            "mobile-app": ScanType.WEB_APP,
            "cloud-security": ScanType.COMPREHENSIVE,
            "social-engineering": ScanType.COMPREHENSIVE,
            "infrastructure": ScanType.NETWORK,
            "container": ScanType.COMPREHENSIVE,
            "dast": ScanType.WEB_APP,
            "sast": ScanType.COMPLIANCE
        }
        
        orchestrator_scan_type = scan_type_mapping.get(data["scan_type"], ScanType.WEB_APP)
        
        # Create scan record
        scan_id = str(uuid.uuid4())
        start_time = datetime.utcnow()
        
        scan = {
            "_id": scan_id,
            "target": data["target"],
            "scan_type": data["scan_type"],  # Store original frontend type
            "orchestrator_scan_type": orchestrator_scan_type.value,  # Store mapped orchestrator type
            "status": "initializing",
            "progress": 0,
            "start_time": start_time,
            "options": data.get("options", {}),
            "config": data.get("config", {}),
            "message": "Initializing penetration test...",
            "results": {
                "vulnerabilities": [],
                "recommendations": [],
                "target_info": {}
            }
        }
        
        # Save to database
        db = get_db()
        db.scans.insert_one(scan)
        
        # Start scan in background using unified orchestrator
        try:
            orchestrator = ScanOrchestrator()
            
            # Create scan request
            scan_request = ScanRequest(
                scan_id=scan_id,
                target=data["target"],
                scan_type=orchestrator_scan_type,
                options=data.get("options", {}),
                user_id="system",  # TODO: Get from auth context
                priority=5
            )
            
            # Submit scan through orchestrator
            orchestrator_task_id = asyncio.run(orchestrator.submit_scan(scan_request))
            
            # Update scan with orchestrator response
            db.scans.update_one(
                {"_id": scan_id},
                {"$set": {
                    "status": "queued",
                    "message": "Penetration test queued for execution",
                    "orchestrator_task_id": orchestrator_task_id
                }}
            )
            scan["status"] = "queued"
            scan["message"] = "Penetration test queued for execution"
            
        except Exception as e:
            db.scans.update_one(
                {"_id": scan_id},
                {"$set": {"status": "failed", "message": f"Failed to start scan: {str(e)}"}}
            )
            return {"error": f"Failed to start scan: {str(e)}"}, 500
        
        return scan, 201
    
    def delete(self, scan_id):
        """
        Cancel a running scan or delete a completed scan.
        
        Args:
            scan_id: ID of scan to cancel/delete
            
        Returns:
            JSON response with operation status
        """
        if not scan_id:
            return {"error": "Scan ID is required"}, 400
        
        db = get_db()
        scan = db.scans.find_one({"_id": scan_id})
        
        if not scan:
            return {"error": "Scan not found"}, 404
        
        # If scan is running, attempt to cancel it
        if scan["status"] in ["initializing", "running"]:
            # TODO: Implement scan cancellation logic
            db.scans.update_one(
                {"_id": scan_id},
                {"$set": {
                    "status": "cancelled",
                    "end_time": datetime.utcnow(),
                    "message": "Scan cancelled by user"
                }}
            )
            return {"message": "Scan cancelled successfully"}, 200
        
        # Otherwise, delete the scan
        result = db.scans.delete_one({"_id": scan_id})
        
        if result.deleted_count == 0:
            return {"error": "Failed to delete scan"}, 500
        
        return {"message": "Scan deleted successfully"}, 200

    def patch(self, scan_id):
        """
        Stop a running scan.
        
        Args:
            scan_id: ID of scan to stop
            
        Returns:
            JSON response with operation status
        """
        if not scan_id:
            return {"error": "Scan ID is required"}, 400
        
        db = get_db()
        scan = db.scans.find_one({"_id": scan_id})
        
        if not scan:
            return {"error": "Scan not found"}, 404
        
        # Check if scan is actually running
        if scan["status"] not in ["initializing", "running"]:
            return {"error": "Scan is not currently running"}, 400
        
        # Update scan status to stopped
        db.scans.update_one(
            {"_id": scan_id},
            {"$set": {
                "status": "stopped",
                "end_time": datetime.utcnow(),
                "message": "Scan stopped by user"
            }}
        )
        
        return {"message": "Scan stopped successfully"}, 200

    def put(self, scan_id):
        """
        Rerun an existing scan with the same configuration.
        
        Args:
            scan_id: ID of scan to rerun
            
        Returns:
            JSON response with new scan details
        """
        if not scan_id:
            return {"error": "Scan ID is required"}, 400
        
        db = get_db()
        original_scan = db.scans.find_one({"_id": scan_id})
        
        if not original_scan:
            return {"error": "Original scan not found"}, 404
        
        # Create new scan with same configuration
        new_scan_id = str(uuid.uuid4())
        start_time = datetime.utcnow()
        
        new_scan = {
            "_id": new_scan_id,
            "target": original_scan["target"],
            "scan_type": original_scan["scan_type"],
            "orchestrator_scan_type": original_scan.get("orchestrator_scan_type", "web_app"),
            "status": "initializing",
            "progress": 0,
            "start_time": start_time,
            "options": original_scan.get("options", {}),
            "config": original_scan.get("config", {}),
            "message": "Rerunning penetration test...",
            "results": {
                "vulnerabilities": [],
                "recommendations": [],
                "target_info": {}
            },
            "rerun_of": scan_id
        }
        
        # Save to database
        db.scans.insert_one(new_scan)
        
        # Start scan in background using unified orchestrator
        try:
            orchestrator = ScanOrchestrator()
            
            # Map the original scan type to orchestrator scan type
            scan_type_mapping = {
                "webapp": ScanType.WEB_APP,
                "network": ScanType.NETWORK,
                "owasp": ScanType.WEB_APP,
                "full": ScanType.COMPREHENSIVE,
                "api-security": ScanType.WEB_APP,
                "mobile-app": ScanType.WEB_APP,
                "cloud-security": ScanType.COMPREHENSIVE,
                "social-engineering": ScanType.COMPREHENSIVE,
                "infrastructure": ScanType.NETWORK,
                "container": ScanType.COMPREHENSIVE,
                "dast": ScanType.WEB_APP,
                "sast": ScanType.COMPLIANCE
            }
            
            orchestrator_scan_type = scan_type_mapping.get(original_scan["scan_type"], ScanType.WEB_APP)
            
            # Create scan request
            scan_request = ScanRequest(
                scan_id=new_scan_id,
                target=original_scan["target"],
                scan_type=orchestrator_scan_type,
                options=original_scan.get("options", {}),
                user_id="system",  # TODO: Get from auth context
                priority=5
            )
            
            # Submit scan through orchestrator
            orchestrator_task_id = asyncio.run(orchestrator.submit_scan(scan_request))
            
            # Update scan with orchestrator response
            db.scans.update_one(
                {"_id": new_scan_id},
                {"$set": {
                    "status": "queued",
                    "message": "Penetration test queued for execution",
                    "orchestrator_task_id": orchestrator_task_id
                }}
            )
            new_scan["status"] = "queued"
            new_scan["message"] = "Penetration test queued for execution"
                
        except Exception as e:
            db.scans.update_one(
                {"_id": new_scan_id},
                {"$set": {"status": "failed", "message": f"Failed to start scan: {str(e)}"}}
            )
            return {"error": f"Failed to start scan: {str(e)}"}, 500
        
        return new_scan, 201