/**
 * Vulnerability Report Viewer
 * Handles displaying detailed vulnerability reports from penetration tests
 */
class VulnerabilityReport {
    constructor() {
        this.scanId = this.getScanIdFromUrl();
        this.scanData = null;
        
        // Initialize the report
        this.init();
    }
    
    /**
     * Initialize the report viewer
     */
    init() {
        // Load scan data
        this.loadScanData();
        
        // Initialize event listeners
        this.initEventListeners();
    }
    
    /**
     * Get scan ID from URL parameters
     * @returns {string} The scan ID
     */
    getScanIdFromUrl() {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get('id');
    }
    
    /**
     * Load scan data from the API
     */
    loadScanData() {
        if (!this.scanId) {
            this.showError('No scan ID provided');
            return;
        }
        
        fetch(`/api/scans/${this.scanId}`)
            .then(response => {
                if (!response.ok) {
                    throw new Error('Failed to load scan data');
                }
                return response.json();
            })
            .then(data => {
                this.scanData = data;
                this.renderReport();
            })
            .catch(error => {
                console.error('Error loading scan data:', error);
                this.showError('Failed to load scan data. Please try again.');
            });
    }
    
    /**
     * Initialize event listeners
     */
    initEventListeners() {
        // Back button
        const backBtn = document.getElementById('back-btn');
        if (backBtn) {
            backBtn.addEventListener('click', () => {
                window.location.href = 'pentest.html';
            });
        }
        
        // Export PDF button
        const exportPdfBtn = document.getElementById('export-pdf-btn');
        if (exportPdfBtn) {
            exportPdfBtn.addEventListener('click', () => {
                this.exportPdfReport();
            });
        }
        
        // Export CSV button
        const exportCsvBtn = document.getElementById('export-csv-btn');
        if (exportCsvBtn) {
            exportCsvBtn.addEventListener('click', () => {
                this.exportCsvReport();
            });
        }
    }
    
    /**
     * Render the vulnerability report
     */
    renderReport() {
        if (!this.scanData) return;
        
        // Update scan overview
        this.updateScanOverview();
        
        // Render vulnerabilities
        this.renderVulnerabilities();
        
        // Render recommendations
        this.renderRecommendations();
        
        // Render target information
        this.renderTargetInfo();
    }
    
    /**
     * Update the scan overview section
     */
    updateScanOverview() {
        // Update basic scan info
        document.getElementById('target-url').textContent = this.scanData.target || '-';
        document.getElementById('scan-id').textContent = this.scanData._id || '-';
        document.getElementById('scan-type').textContent = this.scanData.scan_type || '-';
        
        // Format dates
        if (this.scanData.start_time) {
            const startTime = new Date(this.scanData.start_time);
            document.getElementById('start-time').textContent = startTime.toLocaleString();
        }
        
        if (this.scanData.end_time) {
            const endTime = new Date(this.scanData.end_time);
            document.getElementById('end-time').textContent = endTime.toLocaleString();
            
            // Calculate duration
            if (this.scanData.start_time) {
                const startTime = new Date(this.scanData.start_time);
                const durationMs = endTime - startTime;
                const durationMins = Math.floor(durationMs / 60000);
                const durationSecs = Math.floor((durationMs % 60000) / 1000);
                document.getElementById('duration').textContent = `${durationMins}m ${durationSecs}s`;
            }
        }
        
        // Update vulnerability counts
        if (this.scanData.results && this.scanData.results.vulnerabilities) {
            const vulnerabilities = this.scanData.results.vulnerabilities;
            
            // Count by severity
            const highCount = vulnerabilities.filter(v => v.severity === 'high').length;
            const mediumCount = vulnerabilities.filter(v => v.severity === 'medium').length;
            const lowCount = vulnerabilities.filter(v => v.severity === 'low').length;
            
            document.getElementById('high-count').textContent = `${highCount} vulnerabilities`;
            document.getElementById('medium-count').textContent = `${mediumCount} vulnerabilities`;
            document.getElementById('low-count').textContent = `${lowCount} vulnerabilities`;
            
            // Update risk score
            if (this.scanData.results.risk_score !== undefined) {
                const riskScore = this.scanData.results.risk_score;
                const riskElement = document.getElementById('risk-score');
                
                riskElement.textContent = `${riskScore}/10`;
                
                // Add color based on risk score
                if (riskScore >= 7) {
                    riskElement.classList.add('text-danger');
                } else if (riskScore >= 4) {
                    riskElement.classList.add('text-warning');
                } else {
                    riskElement.classList.add('text-success');
                }
            }
        }
    }
    
    /**
     * Render the vulnerabilities section
     */
    renderVulnerabilities() {
        const container = document.getElementById('vulnerabilities-container');
        
        if (!container) return;
        
        if (!this.scanData.results || !this.scanData.results.vulnerabilities || this.scanData.results.vulnerabilities.length === 0) {
            container.innerHTML = '<p class="text-center">No vulnerabilities found.</p>';
            return;
        }
        
        const vulnerabilities = this.scanData.results.vulnerabilities;
        let html = '';
        
        vulnerabilities.forEach((vuln, index) => {
            const severityClass = this.getSeverityClass(vuln.severity);
            const severityBadge = this.getSeverityBadge(vuln.severity);
            
            html += `
                <div class="vulnerability-card ${severityClass} card mb-3">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h5 class="mb-0">${vuln.name || 'Unnamed Vulnerability'}</h5>
                        ${severityBadge}
                    </div>
                    <div class="card-body">
                        <p><strong>Description:</strong> ${vuln.description || 'No description provided'}</p>
                        <p><strong>Location:</strong> ${vuln.location || 'Unknown'}</p>
                        
                        ${vuln.evidence ? `
                        <div class="mt-3">
                            <h6>Evidence:</h6>
                            <div class="evidence-container">
                                <pre>${this.escapeHtml(vuln.evidence)}</pre>
                            </div>
                        </div>
                        ` : ''}
                        
                        ${vuln.remediation ? `
                        <div class="mt-3">
                            <h6>Remediation:</h6>
                            <p>${vuln.remediation}</p>
                        </div>
                        ` : ''}
                    </div>
                </div>
            `;
        });
        
        container.innerHTML = html;
    }
    
    /**
     * Render the recommendations section
     */
    renderRecommendations() {
        const container = document.getElementById('recommendations-container');
        
        if (!container) return;
        
        if (!this.scanData.results || !this.scanData.results.recommendations || this.scanData.results.recommendations.length === 0) {
            container.innerHTML = '<p class="text-center">No recommendations available.</p>';
            return;
        }
        
        const recommendations = this.scanData.results.recommendations;
        let html = '';
        
        recommendations.forEach((rec, index) => {
            html += `
                <div class="recommendation-card card mb-3">
                    <div class="card-body">
                        <h5 class="card-title">${index + 1}. ${rec.title || 'Recommendation'}</h5>
                        <p class="card-text">${rec.description || 'No description provided'}</p>
                        ${rec.priority ? `<p><strong>Priority:</strong> ${rec.priority}</p>` : ''}
                    </div>
                </div>
            `;
        });
        
        container.innerHTML = html;
    }
    
    /**
     * Render the target information section
     */
    renderTargetInfo() {
        const container = document.getElementById('target-info-container');
        
        if (!container) return;
        
        if (!this.scanData.results || !this.scanData.results.target_info) {
            container.innerHTML = '<p class="text-center">No target information available.</p>';
            return;
        }
        
        const targetInfo = this.scanData.results.target_info;
        let html = '<div class="row">';
        
        // Server information
        html += `
            <div class="col-md-6">
                <h6>Server Information</h6>
                <div class="target-info-item">
                    <strong>Server:</strong> ${targetInfo.server || 'Unknown'}
                </div>
                <div class="target-info-item">
                    <strong>Technologies:</strong> ${targetInfo.technologies ? targetInfo.technologies.join(', ') : 'Unknown'}
                </div>
                <div class="target-info-item">
                    <strong>IP Address:</strong> ${targetInfo.ip_address || 'Unknown'}
                </div>
            </div>
        `;
        
        // Security headers
        html += `
            <div class="col-md-6">
                <h6>Security Headers</h6>
                ${targetInfo.headers ? 
                    Object.entries(targetInfo.headers).map(([key, value]) => 
                        `<div class="target-info-item">
                            <strong>${key}:</strong> ${value}
                        </div>`
                    ).join('') : 
                    '<div class="target-info-item">No security headers found</div>'
                }
            </div>
        `;
        
        html += '</div>';
        
        // Forms and endpoints
        if (targetInfo.forms && targetInfo.forms.length > 0) {
            html += `
                <div class="mt-4">
                    <h6>Forms Detected (${targetInfo.forms.length})</h6>
                    <ul>
                        ${targetInfo.forms.map(form => `<li>${form}</li>`).join('')}
                    </ul>
                </div>
            `;
        }
        
        if (targetInfo.endpoints && targetInfo.endpoints.length > 0) {
            html += `
                <div class="mt-4">
                    <h6>Endpoints Detected (${targetInfo.endpoints.length})</h6>
                    <ul>
                        ${targetInfo.endpoints.map(endpoint => `<li>${endpoint}</li>`).join('')}
                    </ul>
                </div>
            `;
        }
        
        container.innerHTML = html;
    }
    
    /**
     * Export the report as PDF
     */
    exportPdfReport() {
        // In a real implementation, this would generate a PDF
        // For now, we'll just show a notification
        this.showNotification('PDF export functionality will be implemented soon', 'info');
    }
    
    /**
     * Export the vulnerabilities as CSV
     */
    exportCsvReport() {
        // In a real implementation, this would generate a CSV
        // For now, we'll just show a notification
        this.showNotification('CSV export functionality will be implemented soon', 'info');
    }
    
    /**
     * Get the CSS class for a severity level
     * @param {string} severity - The severity level
     * @returns {string} The CSS class
     */
    getSeverityClass(severity) {
        switch (severity.toLowerCase()) {
            case 'high':
                return 'high';
            case 'medium':
                return 'medium';
            case 'low':
                return 'low';
            default:
                return 'info';
        }
    }
    
    /**
     * Get the HTML for a severity badge
     * @param {string} severity - The severity level
     * @returns {string} The HTML for the badge
     */
    getSeverityBadge(severity) {
        let badgeClass = '';
        
        switch (severity.toLowerCase()) {
            case 'high':
                badgeClass = 'badge-danger';
                break;
            case 'medium':
                badgeClass = 'badge-warning';
                break;
            case 'low':
                badgeClass = 'badge-info';
                break;
            default:
                badgeClass = 'badge-secondary';
        }
        
        return `<span class="badge ${badgeClass} severity-badge">${severity.toUpperCase()}</span>`;
    }
    
    /**
     * Show an error message
     * @param {string} message - The error message
     */
    showError(message) {
        this.showNotification(message, 'error');
    }
    
    /**
     * Show a notification
     * @param {string} message - The notification message
     * @param {string} type - The notification type (success, error, info)
     */
    showNotification(message, type) {
        // Check if notification system is available
        if (typeof notificationSystem !== 'undefined') {
            notificationSystem.showNotification(message, type);
        } else {
            // Fallback to alert
            alert(message);
        }
    }
    
    /**
     * Escape HTML to prevent XSS
     * @param {string} html - The HTML to escape
     * @returns {string} The escaped HTML
     */
    escapeHtml(html) {
        if (!html) return '';
        
        const div = document.createElement('div');
        div.textContent = html;
        return div.innerHTML;
    }
}

// Initialize the vulnerability report when the DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    window.vulnerabilityReport = new VulnerabilityReport();
});