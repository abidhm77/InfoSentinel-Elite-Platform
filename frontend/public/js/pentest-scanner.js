/**
 * InfoSentinel Penetration Testing Scanner
 * Provides functionality for launching and monitoring penetration tests
 */
class PentestScanner {
  constructor(options = {}) {
    this.apiUrl = options.apiUrl || '/api';
    this.authToken = options.authToken || localStorage.getItem('auth_token');
    this.pollInterval = options.pollInterval || 5000;
    this.activeScanId = null;
    this.pollTimer = null;
    this.dashboardStats = {
      totalScans: 0,
      activeScans: 0,
      vulnerabilities: 0,
      successRate: 0
    };
    
    // DOM elements
    this.elements = {
      form: document.getElementById('pentest-form'),
      startButton: document.getElementById('start-scan-btn'),
      stopButton: document.getElementById('stop-scan-btn'),
      scanInfo: document.getElementById('scan-info'),
      scanInfoPlaceholder: document.getElementById('scan-info-placeholder'),
      scanTarget: document.getElementById('scan-target'),
      scanType: document.getElementById('scan-type'),
      scanStatus: document.getElementById('scan-status'),
      scanProgress: document.getElementById('scan-progress'),
      scanProgressText: document.getElementById('scan-progress-text'),
      scanTime: document.getElementById('scan-time'),
      recentScans: document.getElementById('recent-scans'),
      refreshScans: document.getElementById('refresh-scans'),
      resultsModal: new bootstrap.Modal(document.getElementById('scan-results-modal')),
      resultsContent: document.getElementById('scan-results-content'),
      exportPdf: document.getElementById('export-pdf'),
      scheduleModal: new bootstrap.Modal(document.getElementById('schedule-scan-modal')),
      toastContainer: document.getElementById('toast-container'),
      // Dashboard stats elements
      totalScansEl: document.getElementById('total-scans-count'),
      activeScansEl: document.getElementById('active-scans-count'),
      vulnerabilitiesEl: document.getElementById('vulnerabilities-count'),
      successRateEl: document.getElementById('success-rate')
    };
    
    this.init();
  }
  
  init() {
    // Check authentication
    if (!this.authToken) {
      window.location.href = 'login.html';
      return;
    }
    
    // Initialize event listeners
    this.initEventListeners();
    this.setupAdvancedConfig();
    
    // Load recent scans
    this.loadRecentScans();
  }
  
  initEventListeners() {
    // Form submission
    this.elements.form.addEventListener('submit', (e) => {
      e.preventDefault();
      this.startScan();
    });
    
    // Refresh scans button
    this.elements.refreshScans.addEventListener('click', () => {
      this.loadRecentScans();
      this.updateDashboardStats();
    });
    
    // Stop scan button
    this.elements.stopButton.addEventListener('click', () => {
      this.stopScan();
    });
    
    // Export PDF button
    this.elements.exportPdf.addEventListener('click', () => {
      this.exportPdfReport();
    });
    
    // Schedule scan button
    document.getElementById('schedule-scan-btn')?.addEventListener('click', () => {
      this.showScheduleModal();
    });
    
    // Schedule scan form submission
    document.getElementById('schedule-form')?.addEventListener('submit', (e) => {
      e.preventDefault();
      this.scheduleScan();
    });
    
    // Delegate for scan result buttons
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('view-results-btn') || e.target.closest('.view-results-btn')) {
        const scanId = e.target.closest('.view-results-btn').dataset.scanId;
        this.viewScanResults(scanId);
      }
      
      if (e.target.classList.contains('stop-scan-btn') || e.target.closest('.stop-scan-btn')) {
        const scanId = e.target.closest('.stop-scan-btn').dataset.scanId;
        this.stopScanById(scanId);
      }
      
      if (e.target.classList.contains('re-run-scan-btn') || e.target.closest('.re-run-scan-btn')) {
        const scanId = e.target.closest('.re-run-scan-btn').dataset.scanId;
        this.reRunScan(scanId);
      }
    });
    
    // View results button click handler
    const viewResultsBtn = document.getElementById('view-results-btn');
    if (viewResultsBtn) {
      viewResultsBtn.addEventListener('click', (e) => {
        const scanId = e.target.dataset.scanId;
        if (scanId) {
          this.viewScanResults(scanId);
        }
      });
    }
    
    // Export PDF button click handler
    const exportPdfBtn = document.getElementById('export-pdf-btn');
    if (exportPdfBtn) {
      exportPdfBtn.addEventListener('click', (e) => {
        const scanId = e.target.dataset.scanId;
        if (scanId) {
          this.exportPdfReport(scanId);
        }
      });
    }
  }

  setupAdvancedConfig() {
    // Setup range sliders
    const maxThreadsSlider = document.getElementById('max-threads');
    const requestDelaySlider = document.getElementById('request-delay');
    
    if (maxThreadsSlider) {
      maxThreadsSlider.addEventListener('input', (e) => {
        document.getElementById('threads-value').textContent = e.target.value;
      });
    }
    
    if (requestDelaySlider) {
      requestDelaySlider.addEventListener('input', (e) => {
        document.getElementById('delay-value').textContent = e.target.value + 'ms';
      });
    }

    // Setup auth type visibility
    const authTypeSelect = document.getElementById('auth-type');
    if (authTypeSelect) {
      authTypeSelect.addEventListener('change', (e) => {
        this.toggleAuthFields(e.target.value);
      });
    }
  }

  toggleAuthFields(authType) {
    const credentialsField = document.getElementById('auth-credentials');
    const headerField = document.getElementById('auth-header');
    const prefixField = document.getElementById('auth-prefix');
    
    if (!credentialsField || !headerField || !prefixField) return;

    const isAuthRequired = authType !== 'none';
    credentialsField.disabled = !isAuthRequired;
    headerField.disabled = !isAuthRequired;
    prefixField.disabled = !isAuthRequired;
    
    if (!isAuthRequired) {
      credentialsField.value = '';
      headerField.value = '';
      prefixField.value = '';
    }
  }
  
  startScan() {
    // Disable form during submission
    this.elements.startButton.disabled = true;
    this.elements.startButton.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Starting scan...';
    
    // Get form data
    const target = document.getElementById('target').value;
    const scanType = document.querySelector('input[name="scan-type"]:checked').value;
    
    // Get advanced options
    const options = {
      deep_scan: document.getElementById('option-deep-scan').checked,
      brute_force: document.getElementById('option-brute-force').checked,
      full_owasp_top_10: document.getElementById('option-full-owasp').checked,
      api_testing: document.getElementById('api-testing')?.checked || false,
      mobile_testing: document.getElementById('mobile-testing')?.checked || false,
      cloud_testing: document.getElementById('cloud-testing')?.checked || false,
      social_engineering: document.getElementById('social-engineering')?.checked || false,
      compliance_check: document.getElementById('compliance-check')?.checked || false
    };

    // Collect advanced configuration
    const advancedConfig = {
      intensity: document.getElementById('scan-intensity')?.value || 'normal',
      maxThreads: parseInt(document.getElementById('max-threads')?.value || '5'),
      requestDelay: parseInt(document.getElementById('request-delay')?.value || '1000'),
      timeout: parseInt(document.getElementById('timeout')?.value || '30'),
      maxPages: parseInt(document.getElementById('max-pages')?.value || '100'),
      maxDepth: parseInt(document.getElementById('max-depth')?.value || '3'),
      excludePatterns: document.getElementById('exclude-patterns')?.value.split('\n').filter(p => p.trim()) || [],
      includePatterns: document.getElementById('include-patterns')?.value.split('\n').filter(p => p.trim()) || [],
      auth: {
        type: document.getElementById('auth-type')?.value || 'none',
        credentials: document.getElementById('auth-credentials')?.value || '',
        header: document.getElementById('auth-header')?.value || '',
        prefix: document.getElementById('auth-prefix')?.value || ''
      }
    };
    
    // Prepare request data
    const requestData = {
      target: target,
      scan_type: scanType,
      options: options,
      config: advancedConfig
    };
    
    // Send request to API
    fetch(`${this.apiUrl}/scans`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.authToken}`
      },
      body: JSON.stringify(requestData)
    })
    .then(response => {
      if (!response.ok) {
        throw new Error(`HTTP error ${response.status}`);
      }
      return response.json();
    })
    .then(data => {
      // Update UI with scan information
      this.activeScanId = data.scan_id;
      this.updateScanInfo(data);
      
      // Start polling for updates
      this.startPolling();
      
      // Show notification
      this.showNotification('Penetration test started', `A new ${scanType} scan has been initiated against ${target}`);
      
      // Re-enable form
        this.elements.startButton.disabled = false;
        this.elements.startButton.innerHTML = '<i class="bi bi-play-fill"></i> Start Penetration Test';
        
        // Show stop button
        this.elements.stopButton.classList.remove('d-none');
        this.elements.stopButton.disabled = false;
        
        // Reset form and refresh scan list
        this.resetForm();
        this.loadRecentScans();
    })
    .catch(error => {
      console.error('Error starting scan:', error);
      
      // Show error notification
      this.showNotification('Error starting scan', error.message, 'error');
      
      // Re-enable form
      this.elements.startButton.disabled = false;
      this.elements.startButton.innerHTML = '<i class="bi bi-play-fill"></i> Start Penetration Test';
    });
  }
  
  updateScanInfo(scanData) {
    // Hide placeholder, show scan info
    this.elements.scanInfoPlaceholder.classList.add('d-none');
    this.elements.scanInfo.classList.remove('d-none');
    
    // Update scan info fields
    this.elements.scanTarget.textContent = scanData.target;
    this.elements.scanType.textContent = scanData.scan_type || 'Unknown';
    this.elements.scanStatus.textContent = scanData.status || 'Initializing';
    
    // Update progress bar
    const progress = scanData.progress || 0;
    this.elements.scanProgress.style.width = `${progress}%`;
    this.elements.scanProgressText.textContent = `${progress}%`;
    
    // Update estimated time
    if (scanData.estimated_time) {
      this.elements.scanTime.textContent = `${scanData.estimated_time} minutes`;
    } else {
      this.elements.scanTime.textContent = 'Calculating...';
    }
    
    // Update progress bar color based on status
    if (scanData.status === 'completed') {
      this.elements.scanProgress.classList.remove('bg-warning', 'bg-danger');
      this.elements.scanProgress.classList.add('bg-success');
      
      // Enable result buttons when scan is completed
      const viewResultsBtn = document.getElementById('view-results-btn');
      const exportPdfBtn = document.getElementById('export-pdf-btn');
      
      if (viewResultsBtn) {
        viewResultsBtn.disabled = false;
        viewResultsBtn.dataset.scanId = scanData.scan_id;
      }
      
      if (exportPdfBtn) {
        exportPdfBtn.disabled = false;
        exportPdfBtn.dataset.scanId = scanData.scan_id;
      }
    } else if (scanData.status === 'failed') {
      this.elements.scanProgress.classList.remove('bg-warning', 'bg-success');
      this.elements.scanProgress.classList.add('bg-danger');
    } else {
      this.elements.scanProgress.classList.remove('bg-success', 'bg-danger');
      this.elements.scanProgress.classList.add('bg-warning');
      
      // Update current phase if available
      if (scanData.current_phase) {
        this.elements.scanStatus.textContent = `${scanData.status} - ${scanData.current_phase}`;
      }
    }
  }
  
  startPolling() {
    // Clear any existing poll timer
    if (this.pollTimer) {
      clearInterval(this.pollTimer);
    }
    
    // Start polling for scan updates
    this.pollTimer = setInterval(() => {
      this.pollScanStatus();
    }, this.pollInterval);
  }
  
  stopPolling() {
    if (this.pollTimer) {
      clearInterval(this.pollTimer);
      this.pollTimer = null;
    }
  }
  
  async stopScan() {
    if (!this.activeScanId) return;
    
    try {
      this.elements.stopButton.disabled = true;
      this.elements.stopButton.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Stopping...';
      
      const response = await fetch(`${this.apiUrl}/scans/${this.activeScanId}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.authToken}`
        },
        body: JSON.stringify({ action: 'stop' })
      });
      
      if (!response.ok) {
        throw new Error(`HTTP error ${response.status}`);
      }
      
      const data = await response.json();
      this.showNotification('Scan Stopped', 'The penetration test has been successfully stopped.', 'success');
      this.stopPolling();
      this.elements.stopButton.classList.add('d-none');
      this.elements.startButton.disabled = false;
      this.loadRecentScans();
      this.updateDashboardStats();
      
    } catch (error) {
      console.error('Error stopping scan:', error);
      this.showNotification('Error', 'Failed to stop scan: ' + error.message, 'error');
      this.elements.stopButton.disabled = false;
      this.elements.stopButton.innerHTML = '<i class="bi bi-stop-circle"></i> Stop Scan';
    }
  }
  
  async stopScanById(scanId) {
    try {
      const response = await fetch(`${this.apiUrl}/scans/${scanId}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.authToken}`
        },
        body: JSON.stringify({ action: 'stop' })
      });
      
      if (!response.ok) {
        throw new Error(`HTTP error ${response.status}`);
      }
      
      this.showNotification('Scan Stopped', 'The penetration test has been successfully stopped.', 'success');
      this.loadRecentScans();
      this.updateDashboardStats();
      
    } catch (error) {
      console.error('Error stopping scan:', error);
      this.showNotification('Error', 'Failed to stop scan: ' + error.message, 'error');
    }
  }
  
  async reRunScan(scanId) {
    try {
      const response = await fetch(`${this.apiUrl}/scans/${scanId}/rerun`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.authToken}`
        }
      });
      
      if (!response.ok) {
        throw new Error(`HTTP error ${response.status}`);
      }
      
      const data = await response.json();
      this.showNotification('Scan Re-run', 'Scan has been scheduled for re-run.', 'success');
      this.loadRecentScans();
      this.updateDashboardStats();
      
    } catch (error) {
      console.error('Error re-running scan:', error);
      this.showNotification('Error', 'Failed to re-run scan: ' + error.message, 'error');
    }
  }

  stopScan() {
    if (!this.activeScanId) {
      this.showNotification('No active scan', 'There is no active scan to stop', 'warning');
      return;
    }

    // Disable stop button to prevent multiple clicks
    this.elements.stopButton.disabled = true;
    this.elements.stopButton.innerHTML = '<i class="bi bi-hourglass-split"></i> Stopping...';

    // Send stop request to API
    fetch(`${this.apiUrl}/scans/${this.activeScanId}`, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.authToken}`
      }
    })
    .then(response => {
      if (!response.ok) {
        throw new Error(`HTTP error ${response.status}`);
      }
      return response.json();
    })
    .then(data => {
      // Show success notification
      this.showNotification('Scan stopped', 'The penetration test has been stopped successfully', 'success');
      
      // Hide stop button and show start button
      this.elements.stopButton.classList.add('d-none');
      this.elements.startButton.disabled = false;
      
      // Stop polling
      this.stopPolling();
      
      // Refresh scan list
      this.loadRecentScans();
      
      // Reset active scan ID
      this.activeScanId = null;
    })
    .catch(error => {
      console.error('Error stopping scan:', error);
      
      // Show error notification
      this.showNotification('Error stopping scan', error.message, 'error');
      
      // Re-enable stop button
      this.elements.stopButton.disabled = false;
      this.elements.stopButton.innerHTML = '<i class="bi bi-stop-fill"></i> Stop Scan';
    });
  }

  resetForm() {
    document.getElementById('pentest-form').reset();
    const threadsValue = document.getElementById('threads-value');
    const delayValue = document.getElementById('delay-value');
    if (threadsValue) threadsValue.textContent = '5';
    if (delayValue) delayValue.textContent = '1000ms';
    this.toggleAuthFields('none');
  }
  
  pollScanStatus() {
    if (!this.activeScanId) return;
    
    fetch(`${this.apiUrl}/scans/${this.activeScanId}`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${this.authToken}`
      }
    })
    .then(response => {
      if (!response.ok) {
        throw new Error(`HTTP error ${response.status}`);
      }
      return response.json();
    })
    .then(data => {
      // Update scan info
      this.updateScanInfo(data);
      
      // Update progress bar with more detailed information
      const progress = data.progress || 0;
      this.elements.scanProgress.style.width = `${progress}%`;
      this.elements.scanProgressText.textContent = `${progress}%`;
      
      // Update current phase if available
      if (data.current_phase) {
        this.elements.scanStatus.textContent = `${data.status} - ${data.current_phase}`;
      }
      
      // If scan is complete, failed, or stopped, stop polling and hide stop button
      if (data.status === 'completed' || data.status === 'failed' || data.status === 'stopped') {
        this.stopPolling();
        this.elements.stopButton.classList.add('d-none');
        this.elements.startButton.disabled = false;
        
        // Show notification
        if (data.status === 'completed') {
          const vulnCount = data.results?.vulnerabilities?.length || 0;
          this.showNotification(
            'Penetration test completed', 
            `Scan completed with ${vulnCount} vulnerabilities found. Risk score: ${data.risk_score || 'N/A'}`
          );
        } else {
          this.showNotification(
            'Penetration test failed', 
            data.error || 'An unknown error occurred',
            'error'
          );
        }
        
        // Refresh scan list
        this.loadRecentScans();
      }
    })
    .catch(error => {
      console.error('Error polling scan status:', error);
    });
  }
  
  loadRecentScans() {
    fetch(`${this.apiUrl}/scans`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${this.authToken}`
      }
    })
    .then(response => {
      if (!response.ok) {
        throw new Error(`HTTP error ${response.status}`);
      }
      return response.json();
    })
    .then(data => {
      this.renderRecentScans(data);
    })
    .catch(error => {
      console.error('Error loading recent scans:', error);
      this.elements.recentScans.innerHTML = `
        <tr>
          <td colspan="9" class="text-center text-danger">
            Error loading scans: ${error.message}
          </td>
        </tr>
      `;
    });
  }
  
  renderRecentScans(scans) {
    if (!scans || scans.length === 0) {
      this.elements.recentScans.innerHTML = `
        <tr>
          <td colspan="9" class="text-center">No scans available</td>
        </tr>
      `;
      return;
    }
    
    // Sort scans by start time (newest first)
    scans.sort((a, b) => {
      return new Date(b.start_time) - new Date(a.start_time);
    });
    
    // Generate HTML for each scan
    const scanRows = scans.map(scan => {
      const startTime = new Date(scan.start_time).toLocaleString();
      const duration = scan.end_time ? 
        this.formatDuration(new Date(scan.end_time) - new Date(scan.start_time)) : 
        'In progress';
      
      const vulnCount = scan.results?.vulnerabilities?.length || 0;
      
      // Determine status badge class
      let statusBadgeClass = 'bg-secondary';
      if (scan.status === 'completed') statusBadgeClass = 'bg-success';
      if (scan.status === 'running') statusBadgeClass = 'bg-warning text-dark';
      if (scan.status === 'failed') statusBadgeClass = 'bg-danger';
      
      return `
        <tr>
          <td>${scan._id.substring(0, 8)}...</td>
          <td>${scan.target}</td>
          <td>${scan.scan_type || 'Unknown'}</td>
          <td><span class="badge ${statusBadgeClass}">${scan.status}</span></td>
          <td>${startTime}</td>
          <td>${duration}</td>
          <td>${vulnCount}</td>
          <td>${scan.risk_score ? `<span class="badge bg-${this.getRiskBadgeColor(scan.risk_score)}">${scan.risk_score}</span>` : 'N/A'}</td>
          <td>
            <button class="btn btn-sm btn-primary view-results-btn" data-scan-id="${scan._id}" ${scan.status !== 'completed' ? 'disabled' : ''}>
              <i class="bi bi-eye"></i> View
            </button>
          </td>
        </tr>
      `;
    }).join('');
    
    this.elements.recentScans.innerHTML = scanRows;
  }
  
  viewScanResults(scanId) {
    // Redirect to the vulnerability report page
    window.location.href = `vulnerability-report.html?id=${scanId}`;
  }
  
  renderScanResults(scan) {
    // Extract data
    const vulnerabilities = scan.results?.vulnerabilities || [];
    const recommendations = scan.results?.recommendations || [];
    const targetInfo = scan.results?.target_info || {};
    const riskScore = scan.risk_score || 0;
    
    // Group vulnerabilities by severity
    const vulnBySeverity = {
      critical: vulnerabilities.filter(v => v.severity === 'critical'),
      high: vulnerabilities.filter(v => v.severity === 'high'),
      medium: vulnerabilities.filter(v => v.severity === 'medium'),
      low: vulnerabilities.filter(v => v.severity === 'low'),
      info: vulnerabilities.filter(v => v.severity === 'info')
    };
    
    // Generate HTML
    let html = `
      <div class="scan-results">
        <div class="row mb-4">
          <div class="col-md-6">
            <h3>Scan Summary</h3>
            <table class="table">
              <tr>
                <th>Target:</th>
                <td>${scan.target}</td>
              </tr>
              <tr>
                <th>Scan Type:</th>
                <td>${scan.scan_type}</td>
              </tr>
              <tr>
                <th>Start Time:</th>
                <td>${new Date(scan.start_time).toLocaleString()}</td>
              </tr>
              <tr>
                <th>Duration:</th>
                <td>${this.formatDuration(new Date(scan.end_time) - new Date(scan.start_time))}</td>
              </tr>
              <tr>
                <th>Status:</th>
                <td><span class="badge bg-success">${scan.status}</span></td>
              </tr>
            </table>
          </div>
          
          <div class="col-md-6">
            <div class="card h-100">
              <div class="card-body text-center">
                <h3>Risk Score</h3>
                <div class="display-1 fw-bold text-${this.getRiskTextColor(riskScore)}">${riskScore}</div>
                <p class="mt-2">
                  ${this.getRiskDescription(riskScore)}
                </p>
              </div>
            </div>
          </div>
        </div>
        
        <div class="row mb-4">
          <div class="col-12">
            <h3>Vulnerability Summary</h3>
            <div class="d-flex justify-content-between flex-wrap">
              <div class="vuln-stat bg-danger text-white">
                <span class="vuln-count">${vulnBySeverity.critical.length + vulnBySeverity.high.length}</span>
                <span class="vuln-label">Critical/High</span>
              </div>
              <div class="vuln-stat bg-warning text-dark">
                <span class="vuln-count">${vulnBySeverity.medium.length}</span>
                <span class="vuln-label">Medium</span>
              </div>
              <div class="vuln-stat bg-info text-dark">
                <span class="vuln-count">${vulnBySeverity.low.length}</span>
                <span class="vuln-label">Low</span>
              </div>
              <div class="vuln-stat bg-secondary text-white">
                <span class="vuln-count">${vulnBySeverity.info.length}</span>
                <span class="vuln-label">Info</span>
              </div>
              <div class="vuln-stat bg-primary text-white">
                <span class="vuln-count">${vulnerabilities.length}</span>
                <span class="vuln-label">Total</span>
              </div>
            </div>
          </div>
        </div>
    `;
    
    // Target information section
    html += `
      <div class="row mb-4">
        <div class="col-12">
          <h3>Target Information</h3>
          <div class="card">
            <div class="card-body">
              <div class="row">
                <div class="col-md-6">
                  <h4>Server Information</h4>
                  <ul class="list-group">
                    <li class="list-group-item d-flex justify-content-between align-items-center">
                      URL
                      <span>${targetInfo.url || 'N/A'}</span>
                    </li>
                    <li class="list-group-item d-flex justify-content-between align-items-center">
                      Server
                      <span>${targetInfo.server || 'Not detected'}</span>
                    </li>
                    <li class="list-group-item d-flex justify-content-between align-items-center">
                      Status Code
                      <span>${targetInfo.status_code || 'N/A'}</span>
                    </li>
                  </ul>
                </div>
                <div class="col-md-6">
                  <h4>Technologies Detected</h4>
                  <div class="tech-tags">
    `;
    
    // Add technology tags
    if (targetInfo.technologies && targetInfo.technologies.length > 0) {
      targetInfo.technologies.forEach(tech => {
        html += `<span class="badge bg-secondary me-2 mb-2">${tech}</span>`;
      });
    } else {
      html += `<p>No technologies detected</p>`;
    }
    
    html += `
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    `;
    
    // Vulnerabilities section
    html += `
      <div class="row mb-4">
        <div class="col-12">
          <h3>Detected Vulnerabilities</h3>
          <div class="accordion" id="vulnerabilitiesAccordion">
    `;
    
    // Add vulnerabilities by severity
    const severities = [
      { key: 'critical', label: 'Critical', color: 'danger' },
      { key: 'high', label: 'High', color: 'danger' },
      { key: 'medium', label: 'Medium', color: 'warning' },
      { key: 'low', label: 'Low', color: 'info' },
      { key: 'info', label: 'Informational', color: 'secondary' }
    ];
    
    severities.forEach((severity, index) => {
      const vulns = vulnBySeverity[severity.key];
      if (vulns.length === 0) return;
      
      html += `
        <div class="accordion-item">
          <h2 class="accordion-header" id="heading${severity.key}">
            <button class="accordion-button ${index > 0 ? 'collapsed' : ''}" type="button" data-bs-toggle="collapse" data-bs-target="#collapse${severity.key}" aria-expanded="${index === 0}" aria-controls="collapse${severity.key}">
              <span class="badge bg-${severity.color} me-2">${vulns.length}</span> ${severity.label} Vulnerabilities
            </button>
          </h2>
          <div id="collapse${severity.key}" class="accordion-collapse collapse ${index === 0 ? 'show' : ''}" aria-labelledby="heading${severity.key}" data-bs-parent="#vulnerabilitiesAccordion">
            <div class="accordion-body">
              <div class="table-responsive">
                <table class="table table-hover">
                  <thead>
                    <tr>
                      <th>Type</th>
                      <th>URL</th>
                      <th>Description</th>
                      <th>Remediation</th>
                    </tr>
                  </thead>
                  <tbody>
      `;
      
      vulns.forEach(vuln => {
        html += `
          <tr>
            <td>${vuln.type}</td>
            <td>${vuln.url}</td>
            <td>${vuln.description}</td>
            <td>${vuln.remediation}</td>
          </tr>
        `;
      });
      
      html += `
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </div>
      `;
    });
    
    html += `
          </div>
        </div>
      </div>
    `;
    
    // Recommendations section
    html += `
      <div class="row mb-4">
        <div class="col-12">
          <h3>Security Recommendations</h3>
          <div class="card">
            <div class="card-body">
              <ol class="recommendations-list">
    `;
    
    recommendations.forEach(rec => {
      html += `<li>${rec}</li>`;
    });
    
    html += `
              </ol>
            </div>
          </div>
        </div>
      </div>
    `;
    
    // Close main div
    html += `</div>`;
    
    // Add CSS for the results
    html += `
      <style>
        .vuln-stat {
          padding: 15px;
          border-radius: 5px;
          text-align: center;
          min-width: 120px;
          margin-bottom: 10px;
        }
        .vuln-count {
          font-size: 2rem;
          font-weight: bold;
          display: block;
        }
        .vuln-label {
          font-size: 0.9rem;
        }
        .recommendations-list li {
          margin-bottom: 10px;
        }
        .tech-tags {
          padding-top: 10px;
        }
      </style>
    `;
    
    // Update modal content
    this.elements.resultsContent.innerHTML = html;
  }
  
  exportPdfReport() {
    // In a real implementation, this would generate and download a PDF
    alert('PDF export functionality would be implemented here in a production environment.');
  };
  
  showNotification(title, message, type = 'info') {
    // This would integrate with the notification system
    console.log(`Notification: ${title} - ${message} (${type})`);
  };
  
  formatDuration(ms) {
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    
    if (hours > 0) {
      return `${hours}h ${minutes % 60}m ${seconds % 60}s`;
    } else if (minutes > 0) {
      return `${minutes}m ${seconds % 60}s`;
    } else {
      return `${seconds}s`;
    }
  };
  
  getRiskBadgeColor(score) {
    if (score >= 75) return 'danger';
    if (score >= 50) return 'warning';
    if (score >= 25) return 'info';
    return 'success';
  };
  
  getRiskTextColor(score) {
    if (score >= 75) return 'danger';
    if (score >= 50) return 'warning';
    if (score >= 25) return 'info';
    return 'success';
  };
  
  getRiskDescription(score) {
    if (score >= 75) return 'Critical risk level. Immediate remediation required.';
    if (score >= 50) return 'High risk level. Prompt remediation recommended.';
    if (score >= 25) return 'Medium risk level. Scheduled remediation advised.';
    return 'Low risk level. Consider remediation in future updates.';
  }
  
  showNotification(title, message, type = 'info') {
    const toastId = `toast-${Date.now()}`;
    const toastHtml = `
      <div id="${toastId}" class="toast align-items-center text-white bg-${type === 'error' ? 'danger' : type === 'success' ? 'success' : 'info'} border-0" role="alert" aria-live="assertive" aria-atomic="true">
        <div class="d-flex">
          <div class="toast-body">
            <strong>${title}</strong><br>${message}
          </div>
          <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
        </div>
      </div>
    `;
    
    if (this.elements.toastContainer) {
      this.elements.toastContainer.insertAdjacentHTML('beforeend', toastHtml);
      const toast = new bootstrap.Toast(document.getElementById(toastId));
      toast.show();
      
      // Clean up after toast is hidden
      document.getElementById(toastId).addEventListener('hidden.bs.toast', () => {
        document.getElementById(toastId).remove();
      });
    }
  }
  
  async updateDashboardStats() {
    try {
      const response = await fetch(`${this.apiUrl}/scans`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${this.authToken}`
        }
      });
      
      if (!response.ok) throw new Error('Failed to fetch stats');
      
      const scans = await response.json();
      
      this.dashboardStats.totalScans = scans.length;
      this.dashboardStats.activeScans = scans.filter(s => s.status === 'running').length;
      this.dashboardStats.vulnerabilities = scans.reduce((total, scan) => 
        total + (scan.results?.vulnerabilities?.length || 0), 0);
      
      const completedScans = scans.filter(s => s.status === 'completed').length;
      this.dashboardStats.successRate = this.dashboardStats.totalScans > 0 
        ? Math.round((completedScans / this.dashboardStats.totalScans) * 100) : 0;
      
      // Update UI
      if (this.elements.totalScansEl) this.elements.totalScansEl.textContent = this.dashboardStats.totalScans;
      if (this.elements.activeScansEl) this.elements.activeScansEl.textContent = this.dashboardStats.activeScans;
      if (this.elements.vulnerabilitiesEl) this.elements.vulnerabilitiesEl.textContent = this.dashboardStats.vulnerabilities;
      if (this.elements.successRateEl) this.elements.successRateEl.textContent = `${this.dashboardStats.successRate}%`;
      
    } catch (error) {
      console.error('Error updating dashboard stats:', error);
    }
  }
  
  showScheduleModal() {
    if (this.elements.scheduleModal) {
      this.elements.scheduleModal.show();
    }
  }
  
  async scheduleScan() {
    const form = document.getElementById('schedule-form');
    const formData = new FormData(form);
    
    const scheduleData = {
      name: formData.get('schedule-name'),
      target: formData.get('schedule-target'),
      scan_type: formData.get('schedule-scan-type'),
      schedule_date: formData.get('schedule-date'),
      schedule_time: formData.get('schedule-time'),
      email_notifications: formData.get('email-notifications') === 'on',
      notes: formData.get('schedule-notes'),
      options: {
        deep_scan: document.getElementById('schedule-deep-scan')?.checked || false,
        brute_force: document.getElementById('schedule-brute-force')?.checked || false
      }
    };
    
    try {
      const response = await fetch(`${this.apiUrl}/schedules`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.authToken}`
        },
        body: JSON.stringify(scheduleData)
      });
      
      if (!response.ok) throw new Error('Failed to schedule scan');
      
      this.showNotification('Scan Scheduled', 'Your scan has been scheduled successfully!', 'success');
      this.elements.scheduleModal.hide();
      form.reset();
      
    } catch (error) {
      console.error('Error scheduling scan:', error);
      this.showNotification('Error', 'Failed to schedule scan: ' + error.message, 'error');
    }
  }
}

// Initialize the scanner when the DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
  const scanner = new PentestScanner({
    apiUrl: '/api'
  });
  
  // Update dashboard stats on load
  scanner.updateDashboardStats();
});